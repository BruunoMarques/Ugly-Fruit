class Delegation
types
	public DelegationName = seq1 of char;
	public LocationName = seq1 of char;
	public UserSet = set of User;
	public Weight = real;
	public ProductSet = map Product to Weight;
	public ProducerSet = set of Producer;
	public UserBaskets = map User to Basket;
	
values
-- TODO Define values here

instance variables
	public name: DelegationName;
	public userCapacity: nat1;
	public location: LocationName;
	public users: UserSet := {};
	public producers: ProducerSet := {};
	public products: ProductSet := { |-> };
	public pendingUsers: UserSet := {};
	public userBaskets: UserBaskets := { |-> };
	inv getUsersWeight() <= getMaxWeight();				-- a capacidade de utilizadores registados na delegacao nunca pode ser excedida
	
operations

	public Delegation : DelegationName*LocationName*nat1 ==> Delegation
		Delegation(nm,ln,uc)==(
			name := nm;
			location := ln;
			userCapacity := uc;
			return self;
		)
		post name = nm and location = ln and userCapacity = uc;
	
	public registerUser : User*Basket`Size ==> ()								-- retorna verdadeiro se o registo do utilizador foi bem sucedido
		registerUser(user, basketSize)==(
			dcl tmp : User := new User("tmp");
			tmp.setBasketSize(<large>);					-- verifica se a delegacao tem capacidade para satisfazer os pedidos de cestas de utilizadores
			
			if ((card users >= userCapacity) or (getrequiredWeight(users union {tmp}) > getMaxWeight()))
			then (
				pendingUsers := pendingUsers union {user};
			)
			else (
				users := users union {user};
				user.setBasketSize(basketSize);
				user.setDelegation(self);
			);
		)
		post card users <= userCapacity and (user in set users or user in set pendingUsers) and getUsersWeight() <= getMaxWeight();
		
	public isUserRegistered : User ==> bool
		isUserRegistered(user)==(
			if user in set users
			then return true
			else return false;
		);
		
	public removeUser(user: User) ==
  	users := users \ {user}
  	pre users <> {} and user in set users
  	post user not in set users;

	public registerProducer : Producer ==> ()
		registerProducer(producer)==(
			producers := producers union {producer};
			setProducts();
		)
		pre producer not in set producers
		post producers <> {};
	
	public setProducts : () ==> ()
		setProducts()==(
			dcl P : ProductSet := { |-> };
			for all producer in set producers do (
				for all product in set dom producer.products do (
					if product in set dom P
					then P(product) := P(product) + producer.products(product)
					else P := P munion { product |-> producer.products(product)};
				);
				products := P;
			);
		);
		
	public removeProduct : Product*real ==> ()
		removeProduct(product,val)==(
    products(product) := (products(product) - val); 
    )
    pre products(product)- val > 0
    post products(product) >= 0;
    
    
	
	public pure getMaxWeight : () ==> nat
	getMaxWeight()==
		getProducerslWeight(producers);
		
	public pure getUsersWeight : () ==> nat
	getUsersWeight()==
		getrequiredWeight(users);
		
	public pure productsPerBasket: () ==> nat
		productsPerBasket()==
		checkVariety(products, card users, 0,0);

functions		
	public getProducerslWeight : ProducerSet -> nat
	getProducerslWeight(producers)==(
	  if producers = {} then 0
		else let p in set producers in p.getWeight() + getProducerslWeight(producers\{p} ) 
		);
			    	            	
	public getrequiredWeight : UserSet -> nat
	getrequiredWeight(users)==(
	  if users = {} then 0
		else let u in set users in 
		if u.basketSize = <small> then 4 + getrequiredWeight(users\{u})
		else 8 + getrequiredWeight(users\{u})
		);
		
	public checkVariety : ProductSet*nat*nat*nat -> nat
		checkVariety(products,basketNum, variety, rest)==(
		  if products = {|->} then variety + floor (rest/basketNum)  
			else let p in set dom products in 
			if products(p) / p.minWeight >= basketNum then checkVariety({p} <-: products, basketNum, variety + 1, rest)
			else checkVariety({p} <-: products, basketNum, variety, rest + floor(products(p) / p.minWeight)) 
			);
		
traces
-- TODO Define Combinatorial Test Traces here
end Delegation